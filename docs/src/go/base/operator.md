# 运算符

## 位运算

位运算只能用于整数类型的变量，且需当它们拥有等长位模式时。

**二元运算符：**

- 按位与 `&`：

  对应位置上的值经过和运算结果，并将 T (true) 替换为 `1`，将 F (false) 替换为 `0`

   ```tex
   1 & 1 -> 1

   1 & 0 -> 0

   0 & 1 -> 0

   0 & 0 -> 0
   ```

- 按位或 `|`：

  对应位置上的值经过或运算结果，并将 T (true) 替换为 `1`，将 F (false) 替换为 `0`

   ```tex
   1 | 1 -> 1

   1 | 0 -> 1

   0 | 1 -> 1

   0 | 0 -> 0
   ```

- 按位异或 `^`：

  对应位置上的值根据以下规则组合：

   ```tex
   1 ^ 1 -> 0

   1 ^ 0 -> 1

   0 ^ 1 -> 1

   0 ^ 0 -> 0
  ```

- 位清除 `&^`：将指定位置上的值设置为 `0`。

  ```go
  package main
  import "fmt"
  func main() {
      var x uint8 = 15
      var y uint8 = 4
      fmt.Printf("%08b\n", x &^ y);  // 00001011
  }
  ```

**一元运算符：**

- 按位补足 `^`：

  该运算符与异或运算符一同使用，即 `m^x`，对于无符号 `x` 使用 “全部位设置为 1” 的规则，对于有符号 `x` 时使用 `m=-1`。例如：

  ```tex
      ^10 = -01 ^ 10 = -11
  ```

- 位左移 `<<`：

  - 用法：`bitP << n`。

  - `bitP` 的位向左移动 `n` 位，右侧空白部分使用 0 填充；如果 `n` 等于 2，则结果是 2 的相应倍数，即 2 的 `n` 次方。例如：

    ```tex
        1 << 10 // 等于 1 KB
        1 << 20 // 等于 1 MB
        1 << 30 // 等于 1 GB
    ```

- 位右移 `>>`：

  - 用法：`bitP >> n`。
  - `bitP` 的位向右移动 `n` 位，左侧空白部分使用 0 填充；如果 `n` 等于 2，则结果是当前值除以 2 的 n 次方。

当希望把结果赋值给第一个操作数时，可以简写为 `a <<= 2` 或者 `b ^= a & 0xffffffff`。

## 逻辑运算符

Go 中拥有以下逻辑运算符：`==`、`!=`、`<`、`<=`、`>`、`>=`。

它们之所以被称为逻辑运算符是因为它们的运算结果总是为布尔值 `bool`。例如：

```go
b3 := 10 > 5 // b3 is true
```

## 算术运算符

常见可用于整数和浮点数的二元运算符有 `+`、`-`、`*` 和 `/`。

（相对于一般规则而言，Go 在进行字符串拼接时允许使用对运算符 `+` 的重载，但 Go 本身不允许开发者进行自定义的运算符重载）

`/` 对于整数运算而言，结果依旧为整数，例如：`9 / 4 -> 2`。

取余运算符只能作用于整数：`9 % 4 -> 1`。

整数除以 0 可能导致程序崩溃，将会导致运行时的恐慌状态（如果除以 0 的行为在编译时就能被捕捉到，则会引发编译错误）；

浮点数除以 `0.0` 会返回一个无穷尽的结果，使用 `+Inf` 表示。

## 运算符与优先级

有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：

```tex
优先级  运算符
 7      ^ !
 6      * / % << >> & &^
 5      + - | ^
 4      == != < <= >= >
 3      <-
 2      &&
 1      ||
```

当然，你可以通过使用括号来临时提升某个表达式的整体运算优先级。
