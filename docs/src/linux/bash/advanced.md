# 常用命令

## 监测进程

### 探查进程

> 当程序在系统中运行时，它被称为**进程**（process），想要监测这些进程，就必须要熟悉 `ps` 命令。

- `ps` 命令**默认只显示**运行在当前终端中**属于当前用户**的那些进程。
- `ps` **常用命令选项**：

| 选项   | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| `-A`   | 显示所有进程。                                               |
| `-w`   | 采用宽输出格式，不限宽度显示。                               |
| `-au`  | 显示较详细的资讯。                                           |
| `-aux` | 显示所有包含其他使用者的进程。                               |
| `-ef`  | `-e`：指定显示系统中运行的所有进程 ；`-f`：扩充输出内容以显示一些有用的信息列。 |

- **应用示例**：

```sh
# 1.输出系统中运行的所有进程的信息列。
[root@localhost ~]# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0  2022 ?        00:11:58 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
root         2     0  0  2022 ?        00:00:06 [kthreadd]
root         4     2  0  2022 ?        00:00:00 [kworker/0:0H]
...
```

| 选项    | 描述                                            |
| ------- | ----------------------------------------------- |
| `UID`   | 启动进程的用户。                                |
| `PID`   | 进程ID。                                        |
| `PPID`  | 父进程的PID（如果该进程是由另一个进程启动的）。 |
| `C`     | 进程生命期中的CPU利用率。                       |
| `STIME` | 进程启动时的系统时间。                          |
| `TTY`   | 进程是从哪个终端设备启动的。                    |
| `TIME`  | 运行进程的累计CPU时间。                         |
| `CMD`   | 启动的程序名称。                                |

### 实时监测进程

> `ps` 命令虽然在收集系统中运行进程的信息时非常有用，但它**只能显示某个特定时间点的信息**。如果想观察那些被频繁换入和换出内存的进程，`ps` 命令就不太方便了。这正是 `top` 命令的用武之地，它与 `ps` 命令相似，`top` 命令**也可以显示进程信息**，但采用的是**实时**方式。

- `top` **常用命令选项**：

| 选项 | 描述           |
| :--- | :------------- |
| `-H` | 显示线程信息。 |

- **应用示例**：

```sh
# 1.监测实时进程。
[root@localhost ~]# top
top - 14:20:26 up 156 days,  3:15,  1 user,  load average: 0.20, 0.19, 0.19
Tasks: 175 total,   1 running, 174 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.5 us,  1.5 sy,  0.0 ni, 95.6 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  3880172 total,   168136 free,  3074520 used,   637516 buff/cache
KiB Swap:        0 total,        0 free,        0 used.   514776 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                 
  657 root      20   0 1283140  65136  17360 S   2.0  1.7   3303:50 kubelet                                                                                                                 
 4649 root      20   0  499340 270096  15228 S   1.7  7.0   3720:39 kube-apiserver 
```

- 输出的第一部分显示的是**系统概况**：

  - **第一行**：显示了**当前时间、系统的运行时长、登录的用户数以及系统的平均负载**（平均负载有3个值，分别是最近1分钟、5分钟、15分钟的平均负载，**值越大说明系统的负载越高**，由于进程短期的突发性活动，出现最近1分钟的高负载值也很常见。但如果近15分钟内的平均负载都很高，就说明系统可能有问题了）。
  - **第二行**：显示了**进程概况**：多少进程处于运行、休眠、停止以及僵化状态（僵化状态指进程已结束，但其父进程没有响应）。
  - **第三行**：显示了**CPU概况**：`top` 会根据进程的属主（用户或是系统）和进程的状态（运行、空闲或等待）将CPU利用率分成几类输出。
  - **随后紧跟的两行**：详细说明了系统**内存的状态**（前一行显示了系统的物理内存的状态，后一行显示了系统交换空间的状态）。

- 输出的最后一部分显示了**当前处于运行状态的进程的详细列表**（类似 `ps` 命令）：

  - `PID`：进程PID。
  - `USER`：进程属主的用户名。
  - `PR`：进程的优先级。
  - `NI`：进程的谦让度。
  - `VIRT`：进程占用的虚拟内存总量。
  - `RES`：进程占用的物理内存总量。
  - `SHR`：进程和其他进程共享的内存总量。
  - `S`：进程的状态（D代表可中断的休眠，R代表运行，S代表休眠，T代表被跟踪或停止，Z代表僵化）。
  - `%CPU`：进程使用的CPU时间比例。
  - `%MEM`：进程使用的可用物理内存比例。
  - `TIME+`：自进程启动到目前为止所占用的CPU时间总量。
  - `COMMAND`：进程所对应的命令行名称，也就是启动的程序名。

### 结束进程

> 用户对 `top` 命令输出有很大的控制权，利用好该工具能找出占用系统大量资源的罪魁祸首，当然，找到之后，下一步就是**结束这些进程**。在 Linux 中有两个命令可以向运行中的进程发出进程信号：`kill` 和 `pkill`。

- **使用说明**：
- `kill` **常用命令选项**：

| 选项            | 描述                                                   |
| :-------------- | :----------------------------------------------------- |
| `-l <信息编号>` | 若不加<信息编号>选项，则 -l 参数会列出全部的信息名称。 |
| `-1 (HUP)`      | 重新加载进程。                                         |
| `-9 (KILL)`     | 杀死一个进程。                                         |
| `-15 (TERM)`    | 正常停止一个进程。                                     |

- **应用示例**：

```sh
# 1.强彻底杀死进程。
[root@localhost ~]# kill -9 2526
```

- `kill` 命令杀死指定进程 PID，需要配合 `ps` 使用，而 `pkill` 直接对进程**对名字进行操作**（允许使用**通配符**），更加方便。
- **应用示例**：

```sh
# 1.该命令将杀掉所有名称以`http`起始的进程。
[root@localhost ~]# pkill http*
```

- **注意事项**：以 `root` 身份使用 `pkill` 命令时**要格外小心，\**避免使用通配符意外地将系统的重要进程终止，导致文件系统损坏\****。

## 监测磁盘空间

### 挂载存储设备

> Linux 文件系统会将所有的磁盘都并入单个虚拟目录。在使用新的存储设备之前，需要将其放在虚拟目录中。这项工作称为**挂载**（mounting）。

- `mount` **常用命令选项**：

| 选项                  | 描述                                               |
| :-------------------- | :------------------------------------------------- |
| `-o`                  | 给文件系统添加特定的选项。                         |
| `-o ro`               | 以只读模式挂载。                                   |
| `-o rw`               | 以可读写模式挂载。                                 |
| `-o loop`             | 使用 loop 模式用来将一个档案当成硬盘分割挂上系统。 |
| `-o user`/`-o nouser` | 使用者可以执行 `mount` / `umount` 的动作。         |
| `-o check=none`       | 挂载文件系统时不执行完整性校验。                   |

- **应用示例**：

``` sh
# 1.将 /tmp/image.iso 这个光碟的 image 档使用 loop 模式挂在 /mnt/cdrom 之下。
[root@localhost ~]# mount -o loop /tmp/image.iso /mnt/cdrom
```

> 移除可移动设备时，不能直接将设备拔下，应该先**卸载**。

- `umount` **常用命令选项**：

| 选项 | 描述                   |
| :--- | :--------------------- |
| `-v` | 执行时显示详细的信息。 |

- **应用示例1**：

```sh
# 1.通过设备名卸载。
[root@localhost ~]# umount -v /dev/sda1
```

- **应用示例2**：

```sh
# 1.通过挂载点卸载。
[root@localhost ~]# umount -v /mnt/mymount/
```

- **注意事项**：**如果有任何程序\**正在使用\**设备上的文件，则系统将\**不允许卸载\**该设备。**

### 使用 df 命令

> 有时需要知道在某台设备上还有**多少磁盘空间**，`df` 命令可以方便地查看所有已挂载磁盘的使用情况。

- `df` **常用命令选项**：

| 选项 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| `-h` | 以人类易读的形式显示磁盘（通常用M来替代兆字节，用G来替代吉字节）。 |

- **应用示例**：

```sh
# 1.设备磁盘使用情况。
[root@localhost ~]# df -h
Filesystem      Size  Used Avail Use% Mounted on
devtmpfs        1.9G     0  1.9G   0% /dev
tmpfs           1.9G   24K  1.9G   1% /dev/shm
tmpfs           1.9G  1.8M  1.9G   1% /run
...
```

- **注意事项**：df 命令输出值反映的是 Linux 系统认为的**当前值**。正在运行的进程有可能创建或删除了某个文件，但尚未释放该文件，则这个值是**不会被计算**进闲置空间的。

### 使用 du 命令

> `df` 命令，很容易发现哪个磁盘存储空间不足。接下来，就是如何应对这种情况，`du` 命令可以显示某个特定目录（默认情况下是**当前目录**）的**磁盘使用情况**，有助于你快速判断系统中是否存在磁盘占用“大户”。

- `du` **常用命令选项**：

| 选项 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| `-c` | 显示所有已列出文件的总大小。                                 |
| `-h` | 按人类易读格式输出大小，分别用 K 表示千字节、M 表示兆字节、G 表示吉字节。 |
| `-s` | 输出每个参数的汇总信息。                                     |

- **应用示例**：

```sh
[root@localhost tmp]# pwd
/tmp
# 1.当前目录磁盘使用情况。
[root@localhost tmp]# du -sh
32K .
```

## 处理数据文件

### 数据排序

> 处理大量数据时需要对数据进行**排序**，此时就会用到一个常用命令 `sort`。

- `sort` 命令会根据锁指定的**默认语言**的排序规则来对文本文件中的数据进行排序。
- `sort` **常用命令选项**：

| 选项                    | 描述                   |
| :---------------------- | :--------------------- |
| `[-k field1[ field2 ]]` | 按照指定的列进行排序   |
| `-n`                    | 将字符串按数值意义排序 |
| `-r`                    | 逆序排序（升序变降序） |
| `-t`                    | 指定字段分隔符         |

- **应用示例**：

```sh
# 1.sort -nr：哪些文件占用磁盘空间最多。
[root@localhost resources]# du -sh * | sort -nr
92K io
24K META-INF
4.0K registry.conf
4.0K README-zh.md
4.0K README.md
4.0K logback.xml
4.0K file.conf.example
4.0K file.conf
```

### 数据搜索

> 经常需要在大文件中查找位于文件中间部分某处的数据行，可以使用 `grep` 命令来帮助**查找**。

- `grep` 命令会在输入或指定文件中逐行搜索匹配指定模式的文本。
- `grep` **常用命令选项**：

| 选项 | 描述                             |
| :--- | :------------------------------- |
| `-v` | 反向搜索。                       |
| `-n` | 显示匹配指定模式的那些行的行号。 |
| `-c` | 统计多少行。                     |
| `-e` | 指定多个匹配模式                 |

### 数据压缩

> Linux 包含多种文件**压缩工具**。

| 工具名     | 文件拓展名 | 描述                                                  |
| :--------- | :--------- | :---------------------------------------------------- |
| `bzip2`    | `.bz2`     | 采用 Burrows-Wheeler 块排序文本压缩算法和霍夫曼编码。 |
| `compress` | `.Z`       | 最初的 Unix 文件压缩工具。                            |
| `gzip`     | `.gz`      | GNU 压缩工具，用 Lempel-Zivwelch 编码。               |
| `xz`       | `.xz`      | 日渐流行的通用压缩工具。                              |
| `zip`      | `.zip`     | Windows 中 PKZIP 工具的 Unix 实现。                   |

- **应用示例**：

```sh
# 1.文件压缩并保存为 *.gz文件
[root@localhost tmp]# gzip file.txt

# 2.目录及其子目录中的所有文件压缩成 *.gz文件
[root@localhost tmp]# gzip -r -v dir

# 3. 文件解压缩并删除压缩文件
[root@localhost tmp]# gzip -d file.gz
```

### 数据归档

> 目前，Unix 和 Linux 中最流行的**归档**工具是 `tar` 命令。

- `tar` **常用命令选项**：

| 选项 | 描述                           |
| :--- | :----------------------------- |
| `-c` | 创建新的 tar 归档文件。        |
| `-x` | 从 tar 归档文件中提取文件。    |
| `-f` | 将结果输出到文件（或设备）。   |
| `-v` | 在处理文件时显示文件名。       |
| `-z` | 将输出传给 gzip 命令进行压缩。 |

- **应用示例：

```sh
# 1.创建归档文件。
[root@localhost tmp]# tar -cvf test.tar *.txt

# 2.提取tar包内容。
[root@localhost tmp]# tar -xvf test.tar 
```

- **提示**：在下载开源软件时经常会看到文件名以 .tgz 结尾，这是经 `gzip` 压缩过的 tar 文件，可以用 `tar -zxvf filename.tgz` 来提取其中的内容。
