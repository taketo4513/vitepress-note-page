# 文件系统

## 探索 Linux 文件系统

> Linux 支持**多种文件系统**。每种文件系统都在存储设备上实现了虚拟目录结构，只是特性略有不同。

### Linux 文件系统的演进

> Linux 最初采用的是一种简单的文件系统，模仿了 Unix 文件系统的功能。

#### `ext` 文件系统

> Linux 操作系统最初引入的文件系统叫作**扩展文件系统**（ *extended file system*，简称 `ext`）。

- 它使用**虚拟目录**处理物理设备并在其中以固定大小的磁盘块（ *fixed-length block* ）形式保存数据。

- `ext` 文件系统使用 **`i` 节点**（`i` node ）**跟踪**存储在虚拟目录中**文件的相关信息**。`i` 节点系统在每个物理存储设备中创建一个单独的表（ 称作 **`i` 节点表** ）来**保存文件信息**。

- 虚拟目录中的每个文件在 `i` 节点表中有对应的条目。

- 系统中各自所跟踪的每个文件的**额外数据**，包括以下内容：

  - 文件名；
  - 文件大小；
  - 文件属主；
  - 文件属组；
  - 文件访问权限；

- 指向存有文件数据的每个块的指针。

- Linux 通过一个**唯一的数值**（ 称作 `i` 节点号 ）来引用 `i` 节点表中的 `i` 节点，这个值是创建文件时由文件**系统分配的**。文件系统是通过 **`i` 节点号**而非文件名和路径来**标识文件**。

#### `ext2`

> 最早的 `ext` 文件**系统限制颇多**，比如文件大小不得超过 2 GB。随后 `ext` 文件系统就**升级到了第二代**拓展文件系统，称作 ext2 。

- `ext2` 在功能上做了**拓展**：
- 在 `i` 节点表加入了文件的创建时间、修改时间以及最后一次访问时间。
- 允许的最大文件大小增至 2 TB，后期又增加到 32 TB。
- 保存文件时按组分配磁盘块。
- `ext2` 文件系统**也有限制**。如果系统在存储文件和更新 `i` 节点表之间发生了什么事情，则两者内容可能**无法同步**。潜在结果是**丢失文件在磁盘上的数据位置**。ext2 文件系统由于容易在系统崩溃或断电时损坏而臭名昭著。

### 日志文件系统

> 日志文件系统为 Linux 系统增加了一层**安全性**。

- 它放弃了之前先将数据直接写入存储设备再更新 `i` 节点表的做法，而是先将文件变更**写入临时文件**（称作日志）。在数据被**成功写到**存储设备和`i` 节点表之后，**再删除对应的日志条目**。
- 如果系统在数据被写入存储设备之前崩溃或断电，则日志文件系统会**读取日志文件**，**处理未提交的数据**。
- Linux 有 **3 种广泛使用的日志方法**，每种的保护等级都不相同：

|   方法   | 描述                                                         |
| :------: | :----------------------------------------------------------- |
| 数据模式 | `i` 节点和文件数据都会被写入日志；数据丢失风险低，但性能差。 |
| 有序模式 | 只有 `i` 节点数据会被写入日志，直到文件数据被成功写入后才会将其删除；在性能和安全性之间取得了良好的折中。 |
| 回写模式 | 只有 `i` 节点数据会被写入日志，但不控制文件数据何时写入；数据丢失风险高，但仍好于不用日志。 |

- **常见的 Linux 日志文件系统**：

| 系统名 | 采用方法         | 特点                                                         | 备注                                         |
| :----: | :--------------- | :----------------------------------------------------------- | :------------------------------------------- |
| `ext3` | 有序模式（默认） | ext2后续版本，支持最大 2 TB的文件，能够管理 32 TB大小的分区。 | 无法恢复误删的文件，也没有提供数据压缩功能。 |
| `ext4` | 有序模式（默认） | ext3后续版本，最大支持 16 TiB的文件，能够管理 1 EiB大小的分区。 | 支持加密、压缩以及单目录下不限数量的子目录。 |
| `JFS`  | 有序模式         | 在用的最旧的日志文件系统之一。只在日志中保存 i 节点数据，直到文件数据被写进存储设备后才将其删除。 | /                                            |
| `XFS`  | 回写模式         | 高性能表现。                                                 | 实际数据并未存进日志文件，有一定的风险。     |

### 卷管理文件系统

> 日志技术，必须在安全性和性能之间做出选择。就文件系统而言，日志技术的替代选择是一种称作**写时复制**（ *copy-on-write*，COW ）的技术。COW 通过**快照**（ *snapshot* ）**兼顾了安全性和性能**。

- 在修改数据时，使用的是**克隆**或**可写快照**。修改过的数据并不会直接覆盖当前数据，而是被放入文件系统中的另一个位置。
- 提示：真正的 COW 系统仅在**数据修改完成之后才会改动旧数据**。**如果不覆盖**旧数据，那么这种操作准确来说称作**写时重定向**（ *redirect-on-write*，ROW ）。不过，通常都将 ROW 简称 COW。
- 从一个或多个磁盘（或磁盘分区）创建的**存储池**提供了生成虚拟磁盘（称作**卷**）的能力。通过存储池，可以根据需要**增加卷**，在提供灵活性的同时**大大减少停机时间**。
- **常见的卷管理特性的文件系统**：

|  系统名   | 特点                                                         |
| :-------: | :----------------------------------------------------------- |
|   `ZFS`   | 拥有数据完整性验证和自动修复功能，支持最大 16 EB的文件，能够管理 256 万亿ZB的存储空间。 |
|  `Btrfs`  | 也称 B-tree 文件系统。稳定易用，能够动态调整已挂载文件系统的大小。 |
| `Stratis` | 提供了更多的管理视角。维护的存储池由一个或多个 XFS 文件系统组成，同时还提供与传统的卷管理文件系统相似的 COW 功能。 |

## 使用文件系统

> Linux 提供了一些实用工具，可以轻松地在命令行进行文件系统操作，**创建**新的文件系统或**修改已有的文件系统**。

### 创建分区

> **首先**，需要在存储设备上**创建可容纳文件系统的分区**。分区范围可以是整个硬盘，也可以是部分硬盘以包含虚拟目录的一部分。

- 重点关注以下 **3  种**：
  - `fdisk`
  - `gdisk`
  - GNU `parted`

- 创建磁盘分区最麻烦的地方就是找出 Linux 系统中的物理硬盘。Linux 采用了一种标准格式来为**硬盘分配设备名称**，在进行分区之前，**必须熟悉**这种格式。
  - **SATA 驱动器**和 **SCSI 驱动器**：设备命名格式为 /dev/sdx，其中字母 x 具体是什么要根据驱动器的检测顺序决定。
  - **SSD NVMe 驱动器**：设备名格式为 /dev/nvmeNn#，其中数字 N 具体是什么要根据驱动器的检测顺序决定（从 0 开始）。# 是分配给该驱动器的名称空间编号（从 1 开始）。
  - **IDE 驱动器**：设备命名格式为 /dev/hdx ，其中字母 x 具体是什么要根据驱动器的检测顺序决定。

#### fdisk

- `fdisk` 可以在**任何**存储设备上创建和管理分区。但是，`fdisk` **只能处理最大 2 TB**的硬盘。如果大于此容量，则只能使用 `gdisk` 或 GNU `parted` 代替。
- 要启动 `fdisk` ，需要指定待分区的存储设备的名称，同时还**必须有超级用户权限**（以 root 用户登录或使用 `sudo` 命令）。
- `fdisk` **常用命令选项**：

| 选项 | 描述                           |
| :--: | :----------------------------- |
| `-l` | 列出素所有分区表。             |
| `-u` | 与 -l 搭配使用，显示分区数目。 |

- `fdisk` **工具操作命令**：

| 命令 | 描述                      |
| :--: | :------------------------ |
| `m`  | 显示菜单和帮助信息。      |
| `a`  | 活动分区标记 / 引导分区。 |
| `d`  | 删除分区。                |
| `l`  | 显示分区类型。            |
| `n`  | 新建分区。                |
| `p`  | 显示分区信息。            |
| `q`  | 退出不保存。              |
| `t`  | 设置分区号。              |
| `v`  | 进行分区检查。            |
| `w`  | 保存修改。                |
| `x`  | 扩展应用，高级功能。      |

- **应用示例**：

```sh
# 1.显示硬盘各分区情况。
[root@localhost etc]# fdisk -lu

Disk /dev/vda: 64.4 GB, 64424509440 bytes, 125829120 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x0009ac89

   Device Boot      Start         End      Blocks   Id  System
/dev/vda1   *        2048   125829086    62913519+  83  Linux
```

#### gdisk

- 如果存储设备**要采用 GUID 分区表**（ *GUID partition table*，GPT ），就要用到 `gdisk`。
- `gdisk` 会识别存储设备所采用的分区类型。如果当前未使用 GPT 方法，则 `gdisk` 会提供相应的选项，将其**转换**为 GPT。
- `gdisk` **工具操作命令**（命令与 `fdisk` 差不多）：

| 命令 | 描述                                |
| :--: | :---------------------------------- |
| `b`  | 将数据备份至文件。                  |
| `c`  | 修改分区名称。                      |
| `d`  | 删除分区。                          |
| `i`  | 显示分区的详细信息。                |
| `l`  | 显示可用的分区类型。                |
| `n`  | 添加一个新分区。                    |
| `o`  | 创建一个新的空 GUID 分区表（GPT）。 |
| `p`  | 显示当前分区表。                    |
| `q`  | 退出，不保存更改。                  |
| `r`  | 恢复和转换选项。                    |
| `s`  | 排序分区。                          |
| `t`  | 修改分区的类型代码。                |
| `v`  | 验证磁盘。                          |
| `w`  | 将分区表写入磁盘并退出。            |
| `x`  | 附加功能。                          |
| `?`  | 显示命令菜单。                      |

- **注意事项**：在**转换设备分区类型的时候务必小心**，所选择的类型**必须与系统固件（ BIOS 或 UEFI ）兼容**，否则，将无法引导设备。**

#### GNU parted

- 不同于 `fdisk` 和 `gdisk` ，GNU `parted` 中的**命令更像是单词**。
- `parted` **允许调整现有的分区大小**，所以可以**很容易地**收缩或扩大磁盘分区。
- **应用示例**：

``` sh
[root@localhost etc]# parted
Warning: Unable to open /dev/sr0 read-write (Read-only file system).  /dev/sr0 has been opened read-only.
GNU Parted 3.1                                                            
Using /dev/sr0
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) quit  
```

### 创建文件系统

> 将数据存储到分区之前，必须使用某种文件系统对其进行**格式化**，以便 Linux 能够使用分区。每种文件系统类型都有自己专门的格式化工具。

- **创建文件系统的命令行工具**：

|     工具     | 用途                 |
| :----------: | :------------------- |
|   `mkefs`    | 创建 ext 文件系统。  |
|   `mke2fs`   | 创建 ext2 文件系统。 |
| `mkfs.ext3`  | 创建 ext3 文件系统。 |
| `mkfs.ext4`  | 创建 ext4 文件系统。 |
|  `jfs_mkfs`  | 创建 JFS 文件系统。  |
|  `mkfs.xfs`  | 创建 XFS 文件系统。  |
|  `mkfs.zfs`  | 创建 ZFS 文件系统。  |
| `mkfs.btrfs` | 创建 Btrfs 文件系统  |

- 并非所有的文件系统工具都已经默认安装过。要**知道某个工具是否可用**，可以使用 `type` 命令。
- **应用示例**：

```sh
# 1.可用工具。
[root@localhost etc]# type mkfs.ext4
mkfs.ext4 is /usr/sbin/mkfs.ext4
[root@localhost etc]# type mkfs.btrfs
mkfs.btrfs is /usr/sbin/mkfs.btrfs

# 2.不可用工具。
[root@localhost etc]# type jfs_mkfs
-bash: type: jfs_mkfs: not found
```

- **提示**：每个文件系统命令都有大量命令行选项，允许你定制如何在分区上创建文件系统。要**查看所有可用的命令行选项**，可以使用 `man` 命令显示相应命令行的手册页。

### 文件系统的检查与修复

> `fsck` 命令可以**检查和修复大部分** Linux 文件系统类型。

- 文件系统可以通过多种方法指定，比如设备名或其在虚拟目录中的挂载点。但在对其使用 `fsck` 之前，必须先卸载设备。（即**只能对未挂载的**文件系统执行 `fsck` 命令）
- `fsck` **常用命令选项**：

| 选项 | 描述                                       |
| :--: | :----------------------------------------- |
| `-a` | 如果检查有错则自动修复。                   |
| `-A` | 检查 /etc/fstab 文件中列出的所有文件系统。 |
| `-N` | 不进行检查，只显示要检查的内容。           |
| `-r` | 出现错误时进行提示。                       |
| `-R` | 同时有 -A 条件时，省略 / 不检查。          |
| `-t` | 指定要检查的文件系统类型。                 |
| `-V` | 在检查时产生详细输出。                     |
| `-y` | 检测到错误时自动修复文件系统。             |

## 逻辑卷管理

> **数据只会越来越多**。在硬盘的标准分区上创建了文件系统，如果硬盘上没有地方了，就得找一个更大的硬盘，手动将已有的文件系统转移到新硬盘。这多少是一种痛苦的体验。这时候可以将另一块硬盘上的分区加入已有的文件系统来**动态地添加存储空间**。Linux **逻辑卷管理器**（ *logical volume manager*，**LVM** ）正式用来做这个的。

### LVM 布局

> LVM 允许将**多个分区组合在一起**，作为单个分区（逻辑卷）进行**格式化**、在  Linux 虚拟目录结构上**挂载**、**存储数据**等。

- **LVM 由 3 个主要部分组成**：
  - **物理卷**（ *physical volume*，PV ）：通过 LVM 的 `pvcreate` 命令创建，**指定了一个未使用的磁盘分区**（或整个驱动器）**由 LVM 使用**。在这个过程中，LVM 结构、卷标和元数据都会被添加到该分区。
  - **卷组**（ *volume group*，VG ）通过 LVM 的 `vgcreate` 命令创建。该命令**会将 PV 加入存储池**，后者随后用于**构建各种逻辑卷**；可以存在多个卷组；被指定为 PV 的分区只能属于单个 VG，但是，被指定为 PV 的其他分区可以属于其他 VG。
  - **逻辑卷**（ *logical volume*，LV ）：通过 LVM 的 `lvcreate` 命令创建。**LV 由 VG 的存储空间块组成**。LV 只能从一个指定的 VG 中创建。不过，多个 LV 可以共享单个 VG。

### Linux 中的 LVM

> `lvm` 是用于**创建和管理** LV 的**交互式实用工具**。如果尚未安装，可以通过 lvm2 （这里2是指版本号）软件包安装。各种 LVM 工具直接在 CLI 中就可以使用，无须进入 `lvm`。

- **首次设置逻辑卷的步骤如下**：
  - 创建物理卷；
  - 创建卷组；
  - 创建逻辑卷；
  - 格式化逻辑卷；
  - 挂载逻辑卷。

#### 创建物理卷（PV）

- 指定作为 PV 的存储设备之前，先**确保已经分区且未使用**。可以使用 `pvcreate` 命令指定要作为 PV 的分区，执行该命令需要有超级用户权限。
- **应用示例**：

```sh
# 1.当前执行操作的用户。
[root@localhost etc]# whoami
root

# 2.列出所有可用块设备信息。
[root@localhost etc]# lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sr0     11:0    1 159.1M  0 rom  
vda    253:0    0    60G  0 disk 
└─vda1 253:1    0    60G  0 part /

# 3.设置PV。
[root@localhost etc]# pvcreate /dev/vda1
...
```

#### 创建卷组（VG）

- **只要是 PV ，就可以加入 VG**。创建 VG 的命令是 `vgcreate` ，如果随后需要向 VG 中添加 PV，可以使用 `vgextend` 命令。
- **应用示例**：

```sh
# 1.检查系统当前的 VG。
[root@localhost etc]# vgdisplay

# 2.创建 VG。（`vg00`为命名）
[root@localhost etc]# vgcreate vg00 /dev/vda1
```

#### 创建逻辑卷（LV）

- 可以使用 `lvcreate` 命令创建 LV，大小由 -L 选项设置，使用的空间取自指定的 VG 存储池。
- **应用示例**：

```sh
# 1.创建 LV。
[root@localhost etc]# lvcreate -L 1g -v vg00

# 2.以下三种命令都可以显示系统 LV信息。
[root@localhost etc]# lvs
[root@localhost etc]# lvdisplay
[root@localhost etc]# lvscan
```

### 使用 Linux LVM

> 一旦创建好 LV，就可以将其视作普通分区。你可以根据需要，扩大或收缩这个分区，但在此之前，**必须将 LV 挂载到虚拟目录结构中**。

#### 格式化和挂载逻辑卷（LV）

- 对于 `LV` ，无须执行任何特殊操作就可以在其上创建文件系统，然后再挂载到虚拟目录结构中。
- **应用示例**：

```sh
# 1.创建ext4文件系统。（这里的`LVname`是上一步创建 LV 时得到的）
[root@localhost etc]# mkfs.ext4 /dev/vg00/LVname

# 2.挂载虚拟目录。
[root@localhost etc]# mkdir my_LV
[root@localhost etc]# mount -t ext4 /dev/vg00/LVname my_LV

# 3.查看虚拟目录。
[root@localhost etc]# ls my_LV
```

#### 扩大或收缩卷组（VG）和逻辑卷（LV）

- **命令**：

|    命令    | 功能              |
| :--------: | :---------------- |
| `vgextend` | 将 PV 加入 VG。   |
| `vgreduce` | 从 VG 中删除 PV。 |
| `lvextend` | 扩大 LV 的容量。  |
| `lvreduce` | 收缩 LV 的容量。  |

- **提示**：想要了解所有的 LVM 命令，可以在命令行中输入`lvm help` 。
