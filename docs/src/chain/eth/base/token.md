# 代币

## 代币

和以太坊交易一样，以太坊的`代币`(Toke)余额并非仅仅局限于代币，例如，以太坊的`以太猫`应用，我们基于它的智能合约查询余额时，得到的结果代表的就是`该地址拥有多少只猫`。为了便于文字表述，我们还是称Token为代币。

以太坊的`代币`余额，主要有下面的两种类型：

1. ETH余额。
2. 智能合约代码定义的对象的拥有数。

不同的`代币`类型，其查询余额的方式也不同。以太坊`代币`余额一般是通过某个以太坊地址来查询的，主要有以下3种查询方式：

1. 通过调用以太坊的接口查询。
2. 使用以太坊浏览器进行查询。
3. 使用以太坊钱包App查询。

第二、三种方式的本质也是通过调用以太坊接口进行查询，不同之处在于这两种查询帮我们封装好了代码层面的东西，查询操作可直接在应用层进行。

查询余额的接口也分为两类，分别是：

1. 以太坊的ETH余额查询接口`eth getBalance`。
2. 以太坊的`eth_call`接口。使用`eth_call`访问智能合约提供的余额查询函数来达到查询的目的，例如ERC20标准提供了`balanceOf`函数。

这两类接口有很大的区别。针对ETH查询，以太坊提供了一个专门的接口`eth_getBalance`，就像sendTransaction和sendRawTransaction一样，都提供了一个专门的接口。而其他的非ETH的`代币`余额查询，包含ERC20代币和非代币资产，只能调用以太坊提供的一个万能接口`eth_call`来查询，且在查询时必须传入正确的data参数。

如下图所示是ERC20代币的查询请求示例。

图中的data，它的前10个字符就是我们在`以太坊交易`一节中讲到的`balanceOf`的`methodId`，后面跟随的参数就是我们所要查询余额的以太坊地址。

图中`method`键对应的值是`eth_call`，目前智能合约的非转账类函数都能通过这个接口进行调用，只需要把合约中对应函数的
`methodId`标明正确和入参设置到data中即可。

为什么是合约中的非转账类函数呢？如果我们在实际的开发中使用`eth_call`来调用合约中的transfer转账函数会怎样呢？

答案是以太坊的`eth_call`用来调用智能合约的transfer函数，既不报错也不会实现真正的数值转账，最终返回的结果是一个`0x字符串`。
